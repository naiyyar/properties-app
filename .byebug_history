continue
@featured_building.live?
@featured_building.expired?
continue
errors
valid?
continue
card.methods
card = BillingService.new.get_card('cus_GRTJi05MaFKccR', 'card_1FuaOmHc3YOlfsKIjcVWETav')
BillingService.new.get_card('cus_GRTJi05MaFKccR', 'card_1FuaOmHc3YOlfsKIjcVWETav')
card_id
customer_id
continue
BillingService.new.get_card(current_user.stripe_customer_id, @billing.stripe_card_id) rescue nil
BillingService.new.get_card(current_user.stripe_customer_id, @billing.stripe_card_id)
@billing.stripe_card_id
current_user.stripe_customer_id
continue
params[:set_customer_id]
!params[:set_customer_id]
params[:set_customer_id]
params[:set_customer_id].to_boolean
params[:set_customer_id].to_bool
params[:set_customer_id]
params
continue
self
strp_customer_id
continue
Customer
user.customer_id || billing_service.create_stripe_customer&.id
billing_service = BillingService.new(stripe_card_id, email, description)
valid?
user.customer_id
user
continue
image_tag "card_brands/#{brand_name(billing.brand)}.svg"
= image_tag "card_brands/#{brand_name(billing.brand)}.svg"
billing.brand
brand_name(billing.brand)
card.present?
billing.stripe_customer_id
continue
params
continue
params[:email]
billing_params
params
continue
billing_params
params
continue
current_user.billings
current_user.billings.pluck(:stripe_customer_id)
current_user.billings
BillingService.new.get_saved_cards(current_user)
current_user
continue
params
continue
params[:payment_token]
payment_token
customer_email
continue
@filterrific.find.where(user_id: @user.id)
@filterrific@filterrific.find.where(user_id: @user.id)
continue
@spreadsheet
@header
continue
max_listing_price_changed?
min_listing_price_changed?
recommended_percent_changed?
avg_rating_changed? 
continue
controller_name
continue
resource.errors
continue
resource.errors
resource.save
resource.errors
build_resource(sign_up_params)
resource
resource.errors
continue
resource.errors.messages
resource.errors
  recaptcha_valid = verify_recaptcha(model: resource, action: 'registration')
  recaptcha_valid = verify_recaptcha(model: @user, action: 'registration')
verify_recaptcha
resource.errors.messages
resource.persisted? and verify_recaptcha
verify_recaptcha
resource.persisted?
continue
verify_recaptcha
resource.persisted?
continue
lower_manhattan_sub_borough
continue
brooklyn_count
uptown_count
pop_nb_counts
@pop_nb_hash
pop_nb_counts
continue
pop_nb_counts ||= 1
pop_nb_counts.present?
pop_nb_counts
pop_neighborhoods
@pop_nb_hash
area
continue
pop_nb_counts
continue
pop_nb_counts
continue
pop_nb_counts
continue
building.building_name
continue
building.building_name
continue
building.all_three_cta?(active_listings)
building.building_name
continue
active_listings.size
active_listings.sie
active_listings
listings
building.has_active_email?
building.active_web_url?
building
building.availability_and_contacts_cta? and active_listings.blank?
building.all_three_cta?(active_listings)
continue
terms.map { |e| [e] * num_or_conds }.flatten
*terms.map { |e| [e] * num_or_conds }.flatten
num_or_conds = 2
terms = terms.map { |e| (e.tr("*", "%") + "%").gsub(/%+/, "%") }
terms = query.to_s.downcase.split(/\s+/)
query.to_s.downcase.split(/\s+/)
query.to_s.downcase
query.to_s
query
continue
amenities.each{|b| b}
amenities.map{|b| b}
amenities
amenities.to_json
amenities.as_json
amenities.to_s
amenities
continue
building.amenities.split(',').map{|ba| puts ba}
building.amenities.split(',').each{|ba| puts ba}
building.amenities.split(',').each{|ba| ba}
building.amenities.split(',').map{|ba| ba}
building.amenities.split(',')
building.amenities
continue
building.amenities
continue
buildings.where('active_web is true and web_url is not null')
buildings.where('active_web is true and web_url is not null').count
buildings.where('active_web is true and web_url is not null')
buildings.where('active_web is true and web_url is not null').present?
name
continue
buildings.where('active_web is true and web_url is not null').present?
buildings.where('active_web is true OR web_url is not null').present?
buildings
name
continue
buildings.where(active_web: true).where.not(web_url: nil)
buildings.first
buildings.count
continue
buildings.count
continue
request.format
params
continue
@from_date + 29.days
@from_date + 30.days
@from_date + 1.month
@from_date
params[:date_to].present?
params
continue
params
continue
params[:commit]
params
continue
Listing.where('date_active >= ? AND date_active <= ?', @from_date, @to_date).count
Listing.where('date_active >= ? AND date_active <= ?', @from_date, @to_date)
@to_date
@from_date
continue
Building.select(:neighborhood, :neighborhoods_parent, :neighborhood3).where(neighborhood: @building.neighborhood)
predifined_neighborhoods.include?(hood)
hood
continue
Building.select(:neighborhood, :neighborhoods_parent, :neighborhood3).exists?
Building.select(:neighborhood, :neighborhoods_parent, :neighborhood3).first
Building.select(:neighborhood, :neighborhoods_parent, :neighborhood3).where(neighborhood: @building.neighborhood).where.not(neighborhoods_parent: nil, neighborhood3: nil).first
Building.all
Building.all.count
Building.all.pluck(:id)
Building.where(neighborhood: 'Midtown').pluck(:id)
Building.where(neighborhood: 'West Village').pluck(:id)
Building.where(neighborhood: 'anana32').pluck(:id)
Building.where(neighborhood: 'anana32').pick(:id)
Building.where(neighborhood: 'anana32').exists?
Building.where(neighborhood: 'anana32').exist?
Building.where(neighborhood: 'anana32').count
Building.where(neighborhood: 'anana').first
building_with_nb3 = Building.where(neighborhood: @building.neighborhood).where.not(neighborhoods_parent: nil, neighborhood3: nil).first
building_with_nb3 = Building.where(neighborhood: @building.neighborhood).where.not(neighborhoods_parent: nil, neighborhood3: nil)
building_with_nb3 = Building.where(neighborhood: @building.neighborhood).where.not(neighborhoods_parent: nil, neighborhood3: nil).count
building_with_nb3 = Building.where(neighborhood: @building.neighborhood).where.not(neighborhoods_parent: nil, neighborhood3: nil)
predifined_neighborhoods.include?(hood)
hood
continue
Building.with_featured_building(buildings, page_num).count
params[:page].to_i
params[:page]
continue
buildings
buildings.present?
continue
buildings.length
buildings.count
buildings = filter_by_listing_prices(buildings, min_price, max_price)
buildings.count
continue
distance
continue
buildings_with_active_listings(buildings).length
buildings.length
buildings.count
filter_params
continue
uploads.pluck(:id, :sort)
continue
uploads.pluck(:id, :sort)
continue
uploads.pluck(:id, :sort)
continue
uploads.pluck(:id, :sort)
continue
uploads.pluck(:id, :sort)
continue
uploads.pluck(:id, :sort)
